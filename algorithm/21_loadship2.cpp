//
// Created by AutumnSigni on 2023/10/23.
//

// 回溯法
// 两种问题 子集树 与 排列树
//
/**
* 装载问题：n个集装箱，装入重量分别为 a  b的轮船 第i个集装箱重量w[i]
 *  n个箱子重量之和<= a+b,找出一个合理方案将n个箱子装入两个轮船
 *  例 n = 3 a=b=50  w ={10,40,40} 有方案 w={20,40,40} 无
 *解： 问题转化，在n个箱子中找一个子集 使得第一个轮船的重量尽可能大 且不超过 a
 *     特殊的 0-1问题，至于第二个集装箱 将集装箱总重量 - 上述装入a的重量 <= b就有方案，否则没有
 *     故也可以用动态规划做，
 *    子集树表示解空间，设解集为{x1,x2...} 每个xi有两种选择 0 ，1
 *    画成树形
 *    可行性约束函数 左分支-> 到目前装入的重量 < a  剪枝
 *    上届函数 右分支   当前重量+剩余的全部装入重量<比之前最好的选择小 剪枝
*/
#include <iostream>
using namespace std;
int n = 3;
int r = 12; //所有集装箱装量之和
int w[4] = {0, 8, 3, 1}; //下标从1开始，对应i的箱子重量
int cw = 0;//当前装入重量
int c = 10; //船的载重量
int x[4];//当前解 0 不选 1 选
int bestX[4];// 最优解
int bestw;//当前选择之前的解集中 最好的选择
void loadShip(int i) {
    if (i > n) {
        //更新最优解
        if (cw > bestw) {
            for (int j = 1; j <= n; ++j) {
                bestX[j] = x[j];//保存最优解
            }
            bestw = cw;
        }
    }
    r -= w[i];//该重量的物品已处理，当前分支结点以后不考虑，故剪掉
    if (cw + w[i] <= c) { //约束条件：不符合的左分支 剪掉
        x[i] = 1;//进左分支表示选
        cw += w[i];//当前重量+w[i]
        loadShip(i + 1); //进左子树搜索
        cw -= w[i];//回溯
    }
    // r += w[i]; //返回到父结点时候的状态
    // r -= w[i]; //同上 这两行是为了理解的
    if (cw + r > bestw) {//上界函数: 不符合的右分支 剪掉
        x[i] = 0; //右边表示不选
        loadShip(i + 1); //进入右子树
    }
    r += w[i]; //返回到父结点时候的状态
}
void printArray(int *a, int row) {
    for (int i = 1; i <=row; ++i) { //下标从1开始
        cout << a[i]<< "\t";
    }
}
int main() {
    loadShip(1);//从第一个箱子开始选择
    cout<<"装入第一个集装箱为1，第二个为 0：";
    printArray(bestX,n);
    return 0;
}